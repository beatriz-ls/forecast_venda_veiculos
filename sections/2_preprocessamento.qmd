
##  {#preprocessamento data-menu-title="Pré Processamento dos dados: Bibliotecas utilizadas"}

[Pré Processamento dos dados]{.slide-title}

[Bibliotecas utilizadas]{.custom-subtitle2}

<hr>

```{python}
#| label: libs
#| echo: true
#| output: false
#| warning: false
#| message: false
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error
from sklearn.neural_network import MLPRegressor
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.optimizers import Adam
```


##  {#tratamento1 data-menu-title="Pré Processamento dos dados: Tratamento dos dados"}

[Pré Processamento dos dados]{.slide-title}

[Tratamento dos dados]{.custom-subtitle2}

<hr>

```{python}
#| label: import_data
#| echo: true
#| output: true
#| warning: false
#| message: false

df = pd.read_excel("Venda Veiculos.xlsx")
df['Data'] = pd.to_datetime(df['Data'])
df = df.sort_values('Data')
df = df.set_index('Data')

# Visualização
df.head()
```


##  {#tratamento2 data-menu-title="Pré Processamento dos dados: Tratamento de dados"}

[Pré Processamento dos dados]{.slide-title}

[Tratamento dos dados]{.custom-subtitle2}

<hr>

```{python}
#| label: descritivas_dados
#| echo: true
#| output: true
#| warning: false
#| message: false
df.isna().sum()
# Período da série
print(df.index.min(), df.index.max())
# Frequência das datas
print(df.index.to_series().diff().value_counts())
```

##  {#tratamento3 data-menu-title="Pré Processamento dos dados: Tratamento de dados"}

[Pré Processamento dos dados]{.slide-title}

[Tratamento dos dados]{.custom-subtitle2}

<hr>

```{python}
#| label: serie
#| echo: true
#| output: true
#| warning: false
#| message: false

plt.figure(figsize=(12, 6))
plt.plot(df.index, df['Unidades'], label='Unidades Vendidas')
plt.title('Série Temporal de Unidades Vendidas')
plt.xlabel('Data')
plt.ylabel('Unidades')
plt.legend()
plt.grid(True)
plt.show()
```

##  {#defasagens data-menu-title="Pré Processamento dos dados: Criando defasagens (lags)"}

[Pré Processamento dos dados]{.slide-title}

[Criando defasagens (lags)]{.custom-subtitle2}

<hr>

::: body-text-s

Depois, criamos **features defasadas** para usar em modelos de séries temporais.  
Cada valor da série recebe colunas com valores anteriores (`lag_1`, `lag_2`, ..., `lag_12`).

:::

```{python}
#| label: lags
#| echo: true
#| output: true
#| warning: false
#| message: false

# Função para criar lags
def create_lagged_features(series, lags=12):
    df_lags = pd.DataFrame({'y': series})
    for lag in range(1, lags + 1):
        df_lags[f'lag_{lag}'] = df_lags['y'].shift(lag)
    return df_lags.dropna()

lags = 12
df_lagged = create_lagged_features(df['Unidades'], lags=lags)
df_lagged.head()
```

##  {#features data-menu-title="Pré Processamento dos dados: Separando features e target"}

[Pré Processamento dos dados]{.slide-title}

[Separando features e target]{.custom-subtitle2}

<hr>

::: body-text-s

Agora separamos X (features) e y (target) e aplicamos escalonamento.

:::

```{python}
#| label: features
#| echo: true
#| output: true
#| warning: false
#| message: false

X = df_lagged.drop(columns='y').values
y = df_lagged['y'].values

# Escalonador (fit no dataset completo só para exemplo)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
X_scaled[:5]
```

##  {#criando_folds data-menu-title="Pré Processamento dos dados: Criando folds de validação temporal"}

[Pré Processamento dos dados]{.slide-title}

[Criando folds de validação temporal]{.custom-subtitle2}

<hr>

::: body-text-s

Aqui usamos TimeSeriesSplit do scikit-learn para criar folds de treino e validação, preservando a ordem temporal.

:::

```{python}
#| label: folds
#| echo: true
#| output: true
#| warning: false
#| message: false

# 3 folds com teste de tamanho 12
tscv = TimeSeriesSplit(n_splits=3, test_size=12)

splits = list(tscv.split(X_scaled))

```

##  {#fold1 data-menu-title="Pré Processamento dos dados: Fold1"}

[Pré Processamento dos dados]{.slide-title}

[Fold1]{.custom-subtitle2}

<hr>


```{python}
#| label: fold1
#| echo: false
#| output: true
#| warning: false
#| message: false

train_index, val_index = splits[0]
X_train_fold, X_val_fold = X_scaled[train_index], X_scaled[val_index]
y_train_fold, y_val_fold = y[train_index], y[val_index]

plt.figure(figsize=(10, 4))
plt.plot(val_index, y_val_fold, label='Validação')
plt.plot(train_index, y_train_fold, label='Treino')
plt.title('Fold 1')
plt.xlabel('Índice temporal')
plt.ylabel('Unidades')
plt.legend()
plt.grid(True)
plt.show()
```

##  {#fold2 data-menu-title="Pré Processamento dos dados: Fold2"}

[Pré Processamento dos dados]{.slide-title}

[Fold2]{.custom-subtitle2}

<hr>


```{python}
#| label: fold2
#| echo: false
#| output: true
#| warning: false
#| message: false

train_index, val_index = splits[1]
X_train_fold, X_val_fold = X_scaled[train_index], X_scaled[val_index]
y_train_fold, y_val_fold = y[train_index], y[val_index]

plt.figure(figsize=(10, 4))
plt.plot(val_index, y_val_fold, label='Validação')
plt.plot(train_index, y_train_fold, label='Treino')
plt.title('Fold 1')
plt.xlabel('Índice temporal')
plt.ylabel('Unidades')
plt.legend()
plt.grid(True)
plt.show()
```


##  {#Fold3 data-menu-title="Pré Processamento dos dados: Fold3"}

[Pré Processamento dos dados]{.slide-title}

[Fold3]{.custom-subtitle2}

<hr>


```{python}
#| label: fold3
#| echo: false
#| output: true
#| warning: false
#| message: false

train_index, val_index = splits[2]
X_train_fold, X_val_fold = X_scaled[train_index], X_scaled[val_index]
y_train_fold, y_val_fold = y[train_index], y[val_index]

plt.figure(figsize=(10, 4))
plt.plot(val_index, y_val_fold, label='Validação')
plt.plot(train_index, y_train_fold, label='Treino')
plt.title('Fold 1')
plt.xlabel('Índice temporal')
plt.ylabel('Unidades')
plt.legend()
plt.grid(True)
plt.show()
```



##  {#treino_teste data-menu-title="Pré Processamento dos dados: Separando Treino/Teste"}

[Pré Processamento dos dados]{.slide-title}

[Separando Treino/Teste]{.custom-subtitle2}

<hr>

::: body-text-s

`tscv.split(X_scaled)` gera os índices de treino e teste para cada fold.

Ao converter em lista, `folds[i]` vai conter uma tupla `(train_idx, test_idx)` para o fold i.

:::

```{python}
#| label: train_test1
#| echo: true
#| output: true
#| warning: false
#| message: false
folds = list(tscv.split(X_scaled))
```

::: body-text-s

Juntando tudo de fold 0 e fold 1 em um único conjunto de treino

:::

```{python}
#| label: train_test2
#| echo: true
#| output: true
#| warning: false
#| message: false
train_idx = np.concatenate([folds[0][0], folds[1][0], folds[0][1], folds[1][1]])
test_idx = folds[2][1]  # Apenas o conjunto de teste do fold 3

```

::: body-text-s

Cria os conjuntos **X_train / X_test** e **y_train / y_test** a partir dos índices.

:::
```{python}
#| label: train_test3
#| echo: true
#| output: true
#| warning: false
#| message: false
#| 
# Separar os dados
X_train, X_test = X_scaled[train_idx], X_scaled[test_idx]
y_train, y_test = y[train_idx], y[test_idx]

```



